Да, это **побитовые** операции над целыми числами. Работают поразрядно над двоичным представлением.

### Базовые правила по битам

* AND `&`: 1, если **оба** бита 1 → `1&1=1`, иначе 0
* OR `|`: 1, если **хотя бы один** бит 1 → `0|1=1`, `1|0=1`, `1|1=1`, `0|0=0`
* XOR `^`: 1, если **биты разные** → `0^1=1`, `1^0=1`, иначе 0

---

### Пример 1: простые числа

Возьмём `x = 6`, `y = 3`.

Напишем в 4 бита (для наглядности):

* `x = 6  = 0110₂`
* `y = 3  = 0011₂`

1. `t = x ^ y` (XOR):

```
  0110
^ 0011
= 0101  => 5
```

2. `t1 = x | y` (OR):

```
  0110
| 0011
= 0111  => 7
```

3. `t2 = x & y` (AND):

```
  0110
& 0011
= 0010  => 2
```

Итого: `t=5`, `t1=7`, `t2=2`.

---

### Пример 2: флаги (маски)

Представим битовые флаги:

```csharp
[Flags]
enum Perm : byte
{
    None  = 0,      // 0000
    Read  = 1 << 0, // 0001
    Write = 1 << 1, // 0010
    Exec  = 1 << 2, // 0100
}
```

* Установить флаги Read и Write:

```csharp
var p = Perm.Read | Perm.Write; // 0001 | 0010 = 0011
```

* Проверить, установлен ли Write:

```csharp
bool hasWrite = (p & Perm.Write) != 0; // 0011 & 0010 = 0010 (≠0) => true
```

* Снять флаг Read:

```csharp
p &= ~Perm.Read; // 0011 & 1110 = 0010
```

* Переключить (инвертировать) флаг Exec:

```csharp
p ^= Perm.Exec; // если был 0 станет 1, если 1 станет 0
```

---

### Пример 3: упаковка цветов (по байтам)

```csharp
byte r = 0x12, g = 0x34, b = 0x56;
// Склеим в 0x00RRGGBB:
int rgb = (r << 16) | (g << 8) | b; // сдвиги + OR
// Извлечь обратно:
byte r2 = (byte)((rgb >> 16) & 0xFF);
byte g2 = (byte)((rgb >> 8) & 0xFF);
byte b2 = (byte)(rgb & 0xFF);
```

---

### Важно не путать

* `&`, `|`, `^` — **побитовые** над числами.
* `&&`, `||` — **логические** над булевыми (с коротким замыканием).

Если нужно, накину ещё примеры: установка/снятие конкретного бита по индексу, маски, чётность через `x & 1`, и т.д.
