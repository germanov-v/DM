Речь о **внутреннем устройстве `Task` в .NET**: когда вы «подписываетесь» на завершение задачи (через `await`, `ContinueWith`, `TaskAwaiter.OnCompleted` и т.п.), это регистрирует **continuation** — делегат, который должен выполниться после завершения `Task`.

### Как это устроено внутри (упрощённо)

* У каждого `Task` есть поле наподобие `m_continuationObject`.
* Пока подписчик один, там часто хранится **просто один объект** (делегат/обёртка).
* Если подписчиков становится **больше одного**, `Task` преобразует хранение в **`List<object>`** (список продолжений).
* Доступ к этому списку происходит **под блокировкой** (lock) — чтобы безопасно добавлять/забирать продолжения из разных потоков.
* При завершении `Task`:

    * под тем же локом список «снимается»/копируется,
    * затем продолжения **итерируются последовательно** (линейный проход) и запускаются (часто через `TaskScheduler`/`SynchronizationContext`/ThreadPool).

Из-за этого:

* регистрация многих продолжений может биться о **лок**,
* выполнение продолжений делает **линейный обход** коллекции (O(n)).

Это **обычно недорого**, но при очень большом числе подписчиков и высокой конкуренции может стать заметно.

---

## Примеры

### 1) Несколько `ContinueWith` → несколько continuation’ов

```csharp
var t = Task.Run(Heavy);

t.ContinueWith(_ => Console.WriteLine("A"));
t.ContinueWith(_ => Console.WriteLine("B"));
t.ContinueWith(_ => Console.WriteLine("C"));
// Внутри t теперь хранится List<object> c тремя продолжениями.
// На завершении t список под локом снимается и A,B,C исполняются по очереди.
```

### 2) Несколько `await` на один и тот же `Task`

```csharp
Task shared = Task.Delay(100);

async Task Foo() { await shared; Console.WriteLine("Foo"); }
async Task Bar() { await shared; Console.WriteLine("Bar"); }
async Task Baz() { await shared; Console.WriteLine("Baz"); }

await Task.WhenAll(Foo(), Bar(), Baz());
// Каждый await регистрирует своё continuation на shared → внутри shared формируется List<object>.
```

### 3) Регистрация через `OnCompleted` вручную

```csharp
var tcs = new TaskCompletionSource();
var awaiter = tcs.Task.GetAwaiter();

awaiter.OnCompleted(() => Console.WriteLine("done 1"));
awaiter.OnCompleted(() => Console.WriteLine("done 2"));
// → два продолжения попадут в общий список tcs.Task
tcs.SetResult(); // завершение: под локом «снять и выполнить» по списку
```

---

## Где «линейный поиск»?

Термин часто используют в двух местах:

1. **Линейный обход** списка продолжений при завершении `Task` — просто пройти по `List<object>` и выполнить каждый.
2. Местами `Task` действительно делает **линейный поиск конкретных типов обёрток** (внутренние классы продолжений) в этом списке, чтобы, например, снять/объединить их. Это детали реализации, но суть та же: коллекция — список, операции — O(n) и под локом.

---

## Почему так сделано?

* В 99% кейсов у задачи **0 или 1 продолжение** → хранить «просто объект» дешевле, чем сразу списки/словарь.
* Когда подписчиков больше — переключаются на `List<object>`, что даёт **минимальные накладные** без лишних структур.
* Лок обязателен, потому что продолжения могут добавляться/сниматься **параллельно** с завершением `Task`.

---

## Практические советы

* **Нормально** иметь несколько продолжений — `Task` к этому готов. Оптимизация нужна только в крайних «высоконагруженных» сценариях.
* Если у вас **десятки/сотни** подписчиков на один `Task`, и это узкое место:

    * вместо множества `ContinueWith/await` на один `Task` добавьте **один** continuation, который уже сам «фан-аутит» работу:

      ```csharp
      var continuations = new List<Action>();
      // в разных местах регистрируем:
      continuations.Add(() => DoA());
      continuations.Add(() => DoB());
      // один раз:
      t.ContinueWith(_ => { foreach (var c in continuations) c(); });
      ```
    * либо **переосмыслите модель**: `Task` — одноразовый сигнал. Для «многоподписочного» оповещения лучше подойдёт

        * `IObservable`/Rx,
        * `Channel<T>`,
        * событие/шина внутри процесса,
        * отдельная `TaskCompletionSource` **на подписчика**.
* Предпочитайте `async/await` вместо «голого» `ContinueWith` — он короче и правильно учитывает `SynchronizationContext`/`TaskScheduler`.
* Не злоупотребляйте синхронными продолжениями (`TaskContinuationOptions.ExecuteSynchronously`) на горячих путях — они могут выполняться прямо в потоке завершения и удлинять критические секции.

---

## Микро‑наблюдение производительности (интуитивно)

* **1 продолжение**: хранится как одиночный объект → минимум аллокаций и блокировок.
* **N продолжений**: список под локом + линейный обход → O(N) на завершении и потенциальные точки конкуренции при регистрации.

Во многих приложениях это не влияет на общую производительность. Но если вы строите высоконагруженный runtime/планировщик — стоит помнить об этих деталях.

Если хочешь, могу накинуть маленький бенчмарк (BenchmarkDotNet) для регистрации 1 vs 1000 continuations и показать разницу по времени/аллокациям.
