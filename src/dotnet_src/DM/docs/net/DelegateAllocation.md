Коротко и по делу:

### Сколько аллоцируется

При захвате `postResult` компилятор создаёт:

1. **Display-class** (объект-замыкание) с полем под `PostBlog? postResult`.

    * x64 .NET: заголовок объекта \~16 байт + одно ссылочное поле 8 байт ⇒ **\~24 байта** (кратно 8, выравнивание уже учтено).
2. **Delegate** для лямбды.

    * Типичная MulticastDelegate на x64 занимает **\~48–64 байт** (зависит от реализации/поля списка вызовов).

Итого на один вызов `QueryAsync` из-за замыкания: **около 70–100 байт** (плюс сам объект `PostBlog`, `List<TagBlog>`, `List<CommentBlog>` — но они вам нужны по логике, это не “налог” замыкания).

Важно: эти 70–100 байт **однажды на вызов**, а не на каждую строку результата.

### Когда и как быстро GC это уберёт

* И замыкание, и делегат — **Gen0** объекты (молодое поколение).
* Они становятся **достижимыми только пока идёт маппинг**. После завершения запроса и выхода из метода (когда делегат/замыкание больше не нужны), они **становятся недостижимыми** и будут собраны **при ближайшей сборке Gen0**.
* Сборки **Gen0 дешёвые и быстрые** — обычно **сотни микросекунд—несколько миллисекунд**, зависят от общего давления по аллокациям в процессе. Точный момент не детерминирован, но на практике такие крошечные объекты живут очень недолго.

### Нужно ли оптимизировать

В большинстве случаев — **нет**, это микроскопические аллокации. Если хотите выжать максимум:

* Инициализируйте `Tags`/`Comments` заранее в конструкторе (`new(capacity: N)`), чтобы реже расширялись массивы внутри списков.
* Возвращайте сразу `postResult`, чтобы не материализовывать лишние коллекции (если они не нужны).
* Полностью убрать замыкание тут нельзя (Dapper не прокидывает state в маппер). Но его цена мизерна.

Если надо, могу показать маленький бенчмарк (BenchmarkDotNet), который замеряет разницу с/без захвата.
